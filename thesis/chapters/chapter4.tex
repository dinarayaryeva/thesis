\chapter{Methodology}
\label{chap:ctrl}

\chaptermark{Forth Chapter Heading}

% viscosity
% thrusters
% control lyapunov function

\chaptermark{Third Chapter Heading}

\todo{\#TODO Reformulate intro}

    The development of a robust control system for underwater robots hinges on a 
    comprehensive understanding of system dynamics and control objectives.
    This chapter explores control design for underwater robots, focusing on the application 
    of sliding mode control to address challenges in marine environments. By integrating 
    robust control strategies, the aim is to enhance the stability, accuracy, and 
    responsiveness of underwater robotic systems operating in dynamic and unpredictable conditions.

\section{Design Considerations}

    This section provides an introduction to control systems, starting with defining objectives 
    that serve as a foundation for understanding subsequent topics.

    \subsection{Control objectives}

    \temp{General control design}
    The main idea of the control system design is to choose such control input $u$ which 
    meets the desired performance specifications while ensuring stability.

    \temp{Underwater control design}
    Underwater robots require precise control systems to navigate and operate effectively
    in challenging marine environments. These control objectives are crucial for ensuring
    the robot's stability, accuracy, and responsiveness:
    \begin{itemize}
        \item Position and Orientation Tracking:
            The robot must accurately follow a desired trajectory, maintaining its position
            and orientation as intended.
        \item Disturbance Rejection:
            The robot should be able to withstand external disturbances, such as ocean
            currents, waves, and sensor noise, to maintain stable tracking performance.
        \item Robustness:
            The control system should be robust to uncertainties in the robot's dynamics
            and environmental conditions, ensuring reliable operation even in unpredictable
            situations.
        \item Real-Time Implementation:
            The control algorithm should be computationally efficient and able to run in
            real-time on the robot's embedded system, enabling prompt and effective
            responses to changing conditions.
    \end{itemize}

    \temp{Connect to the next chapter}
    Next, let us discuss the challenges posed by uncertainties in control system modeling, 
    which must be understood before diving into advanced control techniques.

\subsection{Model Uncertainties}

    \temp{What uncertainties?}
    The estimated model dynamics may not perfectly match the actual system behavior 
    due to imprecise parameter estimates caused by simplified dynamics 
    and external factors. From a control perspective, there exist two primary types 
    of modeling inaccuracies:
    \begin{enumerate}
        \item structured (or parametric) uncertainties
        \item unstructured uncertainties (or unmodeled dynamics)
    \end{enumerate}
    The first kind corresponds to inaccuracies in the model's included terms,
    while the second kind relates to inaccuracies on the
    system order.

    \temp{State which uncertainties ROV has}
    Recalling dynamics of ROV, following parameters may have some imprecision:
    \begin{itemize}
        \item Body parameters. The mass matrix $M_B$ and the matrix of Coriolis forces $C_B$ 
        may unknown due to uncertain values of mass $m$ and inertia matrix $I_0$.
        \item Coefficients of viscous damping $D$. The values for linear and quadratic 
        terms are defined empirically.
        \item Restoring forces $g$. Specifically, water density $\rho$ is environment dependent 
        and whole body volume $\nabla$ is hard to calculate with proper accuracy.
    \end{itemize}
    Further, the approximated value of the parameter $x$ is represented as $\hat x$,
    while the difference between this approximation and the actual value is 
    defined as $\tilde x = \hat x - x$.

    Moreover, added mass parameters $M_A$ and $C_A$ cannot be calculated directly and will 
    be omitted in future calculations. Instead, we will incorporate a common disturbance 
    term $\delta$. 

    \temp{Thruster mapping approximation}
    As stated before, thruster mapping is defined through the configuration 
    matrix $T$ and the DC-gain transfer function $\phi(u)$. However, $\phi(u)$ 
    can be highly nonlinear and voltage dependent (Fig. \ref{image:thrust}).
    \begin{figure}[H]
        \centering\includegraphics*[width=0.8\textwidth]{thruster_real}
        \caption{The relationship between thrust and PWM.}
        \label{image:thrust}
    \end{figure}
    Therefore, it is proposed to model this relation for the half of the range 
    using two linear bounds from the inflection point. This approach is deemed appropriate 
    due to the presence of symmetry. The nominal approximation $k_n$ is defined by the middle line between 
    the lower and upper bounds $k_{min}$ and $k_{max}$, which cover almost the whole possible range (Fig. \ref{image:thrust_apprx}).
    \begin{figure}[H]
        \centering\includegraphics*[width=0.8\textwidth]{thruster_apprx}
        \caption{The thruster mapping approximation.}
        \label{image:thrust_apprx}
    \end{figure}
    The function can be expressed as $\hat{\phi}(u) = k\cdot u$, where $k$ is a slope 
    coefficient. The value of $k$ should satisfy $k_{min} < k < k_{max}$, and its estimate 
    is given by $k_n = \frac{k_{max} - k_{min}}{2}$.
    
    Thus, the thruster mapping takes the form:
    $$
    \hat{\bar{f}}^B=T\hat{\phi}(u) = kTu = Bu
    $$

    \temp{Conclusion}
    To summarize, the ultimate goal of the underwater control system is to follow the desired 
    trajectory ${\bar r}_{des}^B$ even in the presence of external disturbances and uncertainties. 
    By measuring the difference between the actual trajectory ${\bar r}^B$ and the desired trajectory, 
    we obtain the tracking error, which is expressed as ${\tilde{\bar r}}^B = {\bar r}_{des}^B - {\bar r}^B$. 
    
    The control objective can be reformulated to achieve ${\tilde{\bar r}}^B\rightarrow 0 $ as $t\rightarrow \infty$, 
    meaning that the tracking error should approach zero as time progresses towards infinity.

    \temp{Control affected}
    As discussed earlier, modeling inaccuracies can have strong adverse effects on nonlinear 
    control systems. Therefore, any practical design must handle them explicitly. 
    Inverse dynamics control can be a good starting point for deriving complex nonlinear 
    control approaches, as it addresses the nonlinearities present in the system.
    % Two major and complementary approaches to dealing with model uncertainty 
    % are robust and adaptive control. Further, we are going to examine the simple approach to 
    % robust control, so-called sliding control methodology.

\section{Inverse dynamics}

    \temp{Intro to ID}
    Inverse dynamics is a nonlinear control technique that provides a trajectory tracking
    by calculating the required joint actuator torques to achieve a given trajectory. 
    This approach relies on exact cancellation of nonlinearities in the robot equation of motion.

    \temp{More on inverse dynamics}
    The inverse dynamics control is directly related to the solution of the inverse
    dynamics problem. By appropriately inverting the dynamic model, a control law can 
    cancel the nonlinear part of the dynamics, decouple the interactions 
    between the regulated variables, and specify the time characteristics of the decay of the 
    task errors.

    \temp{Control design}
    Recalling the system dynamics equation, we can design the following control law to 
    linearize the system:
    $$
        u = B^{+}(Ma +
        C(\bar{v}^B)\bar{v}^B +
        D(\bar{v}^B)\bar{v}^B +
        g(\bar{r}^N))
    $$
    where ${a}$ is outer-loop control to be designed as a proportional-derivative (PD) controller:
    $$
    a = \dot{v}_{des}^B - K_p \tilde{{\bar{r}}}^B - K_d \tilde{{\bar{v}}}^B
    $$ 

    \temp{Introduce uncertainties}
    In order to determine the required control inputs, it is important to have an accurate 
    model of the system dynamics. However, this approach may not be effective when dealing 
    with nonlinear systems that involve uncertainties and disturbances.

    The equation () becomes more complex when system parameters and disturbances are 
    unknown:
    $$
    \hat u = \hat{B}^{+}(\hat{M}a + \hat{C}(v^B)v^B + \hat{D}(v^B)v^B + 
    \hat{g}(r^B))
    $$

    \temp{Control analysis}
    Substitution to the dynamics yields:
    $$
    \dot{v}^B = M^{-1}(B\hat{B}^{+}f - \hat f - \delta) + 
    M^{-1}B\hat{B}^{+}\hat{M}a
    $$
    with $f = 
    C(\bar{v}^B) \bar{v}^B + D(\bar{v}^B) \bar{v}^B + g(\bar{r}^N)$

    \temp{Error dynamics}
    In terms of tracking error $e = \tilde{r}^B$, the following system can 
    be designed:
    $$
    \begin{cases}
        e &= \tilde{r}^B \\
        \dot e &= \tilde{v}^B \\
        \ddot e &= \dot{\tilde{v}}^B = \dot{v}_{des}^B - \dot{v}^B = \\
        &= \dot{v}_{des}^B - M^{-1}(B\hat{B}^{+}f - \hat f - \delta) + 
    (M^{-1}B\hat{B}^{+}\hat{M} - I)(\dot{v}_{des}^B - K_pe - K_d \dot e)
    \end{cases}
    $$

    \todo{\#TODO Add analysis}

    % \temp{Lyapunov analysis}
    % Let us define the Lyapunov function as:
    % \[
    % V(e) = \frac{1}{2} e^T M e
    % \]
    % Taking the time derivative of $V(e)$, we have:
    % \[
    % \dot{V}(e) = e^T M \dot{e}
    % \]
    % Substituting the expression for $\ddot{e}$ into $\dot{V}(e)$, we get:
    % \[
    % \dot{V}(e) = e^T \left( B\hat{B}^{+}f - \hat{f} - \delta \right) + e^T (M^{-1}B\hat{B}^{+}\hat{M} - I) M \dot{v}_{des}^B
    % \]

    As a result, the inverse dynamics technique may not be the best option for effectively 
    controlling underwater systems. Further we introduce sliding mode control, which is a robust 
    control technique that can achieve desired control objectives in the presence of uncertainties.

\section{Sliding Mode}

    \temp{Intro to SMC}
    As discussed before, there are several robust controller
    designs available. However, the sliding mode approach suggested by \todo{(Spong - ?)}
    is highly regarded as the most sophisticated and frequently implemented one.

    \temp{SMC definition}
    Sliding mode control (SMC) is a nonlinear control method that guarantees
    robust control of systems with uncertainties and disturbances.
    This technique involves developing a sliding surface within the state
    space and directing the system's trajectory to slide along this surface (Fig. \ref{image:sliding_mode}).

    \begin{figure}[H]
        \centering\includegraphics*[width=0.5\textwidth]{sliding_mode}
        \caption{The general sliding mode scheme}
        \label{image:sliding_mode}
    \end{figure}

    \temp{Advantages to use SMC}
    Compared to other nonlinear control methods, SMC is a relatively straightforward
    solution to implement with a basic understanding of system dynamics and sliding
    surface design. SMC provides a fast transient response due to the sliding dynamics, which makes 
    it possible to track desired references or trajectories quickly. Additionally, 
    the sliding surface ensures robustness to uncertainties and disturbances by 
    making the system behavior insensitive to these factors. 
    
    In summary, SMC is a simple and effective solution for controlling nonlinear systems.

\subsection{Sliding Surface Design}

    \temp{Sliding surface}
    In sliding mode control, a sliding surface is a hyperplane in
    the state space that defines the desired system behavior.
    The control objective is to force the system's trajectory to slide
    long this surface. Once the system's trajectory reaches the sliding surface,
    it will remain on the surface as long as the control law is applied (Fig. \ref{image:sliding_phases}).

    \begin{figure}[H]
        \centering\includegraphics*[width=0.9\textwidth]{sliding_phases}
        \caption{The phases of sliding mode control}
        \label{image:sliding_phases}
    \end{figure}

    \temp{Properties of SMC}
    The design of the sliding surface is critical for the performance of the SMC
    system. The sliding surface should be:
    \begin{itemize}
        \item Reachable: The system's trajectory should be able to reach the sliding
            surface in a finite amount of time.
        \item Invariant: Once the system's trajectory reaches the sliding surface, it
            should remain on the surface for all future time.
        \item Attractive: The control law should attract the system's trajectory to the
            sliding surface and keep it there.
    \end{itemize}

    \temp{Invariant sets}
    In order to satisfy the conditions above, the sliding surface is designed to be an invariant set.
    Invariant sets are sets of states in the state space that, once entered, cannot be exited under 
    the action of the control law.

    \temp{General equation}
    Let us define time-varying surface $\mathcal{S}$ in the state space $\mathbb{R}^n$
    given by scalar equation $s(\bar{r}^B, t)$:
    $$
        s(\bar{r}^B, t) = (\frac{d}{dt} + \lambda)^{n-1}\tilde{\bar{r}}^B
    $$
    where $n$ is the order of the system and $\lambda$ is a positive scalar.
    % \todo{\#TODO Add more analysis on $\lambda$}

    \temp{Sliding condition}
    In order to ensure convergence of $s$ along all system trajectories in finite time, 
    let us define Lyapunov candidate $V = s^2$ as the squared distance to the surface.
    The sliding condition can then be formulated accordingly:
    $$
    \frac{dV}{dt} < -\eta \sqrt{V} \text{\quad or \quad}
    \frac{1}{2}\frac{d}{dt}\|s\|^2 = s^T\dot{s} < \eta \|s\|
    $$
    where $\eta>0$ defines the rate of convergence to the sliding surface.

    \temp{Invariance}
    Satisfying sliding condition, makes the surface an invariant set
    and implies convergence to $\tilde{r}^B$, since the system described by 
    the differential equation:
    $$
        s = (\frac{d}{dt} + \lambda)^{n-1}\tilde r^B = 0
    $$
    is inherently stable and remains at the equilibrium point $\tilde r^B = 0$.

    \temp{New control objective}
    Applying such transformation yields a new representation of the tracking performance:
    $$
        s \rightarrow 0 \Rightarrow \tilde{r}^B \rightarrow 0
    $$
    Meaning, that the problem of tracking $r^B$ is equivalent to remaining on
    the sliding surface. Thus, the problem of tracking the $n$-dimensional vector $r^B$
    can in effect be replaced by a first order stabilization problem in $s$.

\subsection{Control Law Design}

    \temp{Control law}
    The controller comprises two distinct components: nominal control $a_n$, 
    and an additional robust part $a_s$ (Fig. \ref{image:control_scheme}): 
    $$
        a = a_n + a_s
    $$
    \begin{figure}[H]
        \centering\includegraphics*[width=0.8\textwidth]{control_scheme}
        \caption{The sliding mode control scheme}
        \label{image:control_scheme}
    \end{figure}
    The nominal control $a_n$ aims to compensate for the system's dynamics, 
    while the robustifying component $a_s$ is designed to enhance the 
    controller's stability and performance by providing additional corrective 
    action to counteract uncertainties and disturbances.

    \temp{System dynamics with uncertainties}
    By taking into account the impact of both dynamic approximations 
    and disturbances, we can obtain the following dynamics of the 
    system:
    $$
    M \dot{\bar{v}}^B + C(\bar{v}^B) \bar{v}^B+D(\bar{v}^B) \bar{v}^B+g(\bar{r}^N)
     + \delta = Bu
    $$

    \temp{Virtual control}
    To simplify computations, we can use a virtual control, $f_v = Tu$, which can represent 
    the desired behavior of the system without introducing input uncertainty. This can make the control problem easier to 
    formulate, leading to more efficient algorithms and computational procedures. 

    \temp{Inverse dynamics}
    Using the inverse dynamics approach, we can apply the outer loop 
    controller to partially linearize the system with model estimates:
    $$
    \hat{f}^B = \hat{B}u = \hat{k}Tu = \hat{k}f_v = \hat{M}a + \hat{C}(v^B)v^B + \hat{D}(v^B)v^B + \hat{g}(r^B)
    $$
    Expressing virtual control input, we obtain:
    $$
    f_v = \frac{\hat{M}a + \hat{C}(v^B)v^B + \hat{D}(v^B)v^B + \hat{g}(r^B)}{\hat{k}}
    $$
    Substitution to the dynamics yields the equation:
    $$
        \dot{\bar{v}}^B = M^{-1}(\frac{k}{\hat{k}}\hat{f}(\bar{r}^N, \bar{v}^B) - f(\bar{r}^N, \bar{v}^B)
         - \delta) + \frac{k}{\hat{k}}M^{-1}\hat{M}a \\
        = F(\bar{r}^N, \bar{v}^B) + Ka
    $$
    with 
    $f(\bar{r}^N, \bar{v}^B) = 
    C(\bar{v}^B) \bar{v}^B + D(\bar{v}^B) \bar{v}^B + g(\bar{r}^N)$

    \temp{Sliding condition}
    The time derivative of $s$ is connected to dynamics as follows:
    $$
    \dot{s} = \dot{\tilde{\bar{v}}}^B + \lambda \tilde{\bar{v}}^B = 
    a_n - \dot{\bar{v}}^B = a_n - F - K(a_n + a_s) = w - Ka_s 
    $$
    with $w = (I - K)a_n - F $

    Substitution to sliding condition yields:
    $$
    s^Tw- s^TKa_s  \leq \|s\|\|w\| - s^TKa_s  \leq - \eta \|s\|
    $$

    \temp{Apply matrix property}
    Let us recall that for any symmetric matrix P:
    $$
    \sigma^2_{min} \|x\|^2 \leq \|x^TPx\| \leq \sigma^2_{max} \|x\|^2
    $$
    with $\sigma_{min}$ and $\sigma_{max}$ being the largest and smallest 
    eigenvalues of matrix P.
    % \begin{figure}[H]
    %     \centering\includegraphics*[width=0.5\textwidth]{matrix_boundary}
    %     \caption{The boundaries for the matrix.}
    %     \label{image:matrix_boundary}
    % \end{figure}

    Thus we can choose the stabilizing control $a_s$ as:
    $$
        a_s = \frac{\alpha \hat{k}}{\sigma_{max}^2}\hat{M}^{-1}\frac{s}{\|s\|} = 
        \rho \frac{s}{\|s\|} 
    $$ 
    where $\sigma_{max}$ is maximal singular value of $M^{-1}$
    which provide:
    $$
        \|s\|\|w\| - s^TKa_s \leq 
        \|s\|\|w\| - k \frac{\alpha}{\sigma^2_{max}\|s\|}s^TM^{-1}s \leq 
        \|s\|\|w\| - \alpha k \|s\|
    $$
    but by definition $k_{min} < k < k_{max}$, therefore
    $$
        \|s\|\|w\| - \alpha k \|s\| \leq
        \|s\|\|w\| - \alpha k_{min} \|s\| < - \eta \|s\|
    $$
    Setting gain $\alpha$ accordingly to:
    $$
    \alpha > \frac{\|w\| + \eta}{k_{min}}
    $$
    will satisfy sliding conditions.

    The final expression for sliding control:
    $$    
    a_s = 
    \begin{cases}
    \rho \frac{s}{\|s\|}, \quad \|s\| > 0\\
    0, \quad \|s\| = 0 
    \end{cases}
    $$

    \temp{Solve chattering problem}
    In order to reduce chattering, the controller above is effectively smoothed using
    the boundary layer:
    $$
    a_s = 
    \begin{cases}
    \rho \frac{s}{\|s\|}, \quad \|s\| >\epsilon\\
    \rho \frac{s}{\epsilon}, \quad \|s\| \leq\epsilon
    \end{cases}
    $$
    where $\epsilon$ is the boundary layer thickness.

    \begin{figure}[H]
        \centering\includegraphics*[width=0.6\textwidth]{boundary}
        \caption{The sliding mode scheme with boundary layer}
        \label{image:boundary}
    \end{figure}

    \temp{Nominal torque}
    The nominal control $a_n$ can be 
    designed in a form of PD controller:
    $$
        a_n = - K_0\tilde{v}^B - K_1\tilde{r}^B
    $$

    \temp{Final law}
    The resulting controller is then given as follows:
    \begin{align*} 
        &\hat u = \hat{B}^{-1}(\hat{M}a + \hat{C}(v^B)v^B + \hat{D}(v^B)v^B + \hat{g}(r^B)) \\
        &a = a_n + a_s \\
        &a_n = - K_0\tilde{v}^B - K_1\tilde{r}^B \\
        &s = \tilde{\bar{v}}^B + \lambda \tilde{\bar{r}}^B \\
        &a_s = 
        \begin{cases}
        \rho \frac{s}{\|s\|}, \quad \|s\| >\epsilon\\
        \rho \frac{s}{\epsilon}, \quad \|s\| \leq\epsilon
        \end{cases}
    \end{align*}

\section{Optimization control}

% \section{Stability analysis}
% % lyapunov candidate
% In order to prove global stability of the system, let the Lyapunov candidate will be:
% $$
%     V = q^TPq
% $$
% Let us take the time derivative, we will get
% $$
%     \dot V = ...
% $$

% % LaSalle theorem
% However, we need to discover if $\dot V = 0$ even while $e \neq 0$.
% According to LaSalle theorem ...

\section{Summary}

\todo{\#TODO Summarize the main findings of the chapter.}

The methodology of robust control via sliding mode can be formulated in following steps:
\begin{itemize}
    \item Define the sliding surface $s(y, t)$
    \item Derive nominal control $\hat{u}$ (our best guess) that may achieve $\dot{s} = 0$
    \item Modify control law by discontinues term that will bring system to sliding mode
    by satisfying the sliding condition.
\end{itemize}

\todo{Discuss the limitations and potential extensions of the SMC
    controller.}

\begin{figure}[H]
    \centering\includegraphics*[width=0.99\textwidth]{full_rov_state}
\end{figure}


